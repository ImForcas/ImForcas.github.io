<html><head><base href="/">
<title>Horror Forest</title>
<style>
  body { margin: 0; }
  canvas { width: 100%; height: 100%; display: block; }
  #loadingScreen {
    position: fixed;
    width: 100%;
    height: 100%;
    background: black;
    color: red;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    font-family: 'Courier New', monospace;
  }
  #collectibles { 
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    font-family: 'Courier New', monospace;
  }
  #flashlight {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.85) 50%, rgba(0,0,0,1) 100%);
  }
  #titleScreen {
    position: fixed;
    width: 100%;
    height: 100%;
    background: black;
    color: red;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    font-family: 'Courier New', monospace;
  }
  #titleScreen h1 {
    font-size: 3em;
    margin-bottom: 30px;
    text-shadow: 0 0 10px red;
  }
  #startButton {
    padding: 15px 30px;
    font-size: 1.5em;
    background: red;
    color: black;
    border: none;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    transition: all 0.3s;
  }
  #startButton:hover {
    background: darkred;
    color: white;
    transform: scale(1.1);
  }
  #winScreen {
    position: fixed;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    color: green;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1500;
    font-family: 'Courier New', monospace;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
</head>
<body>
<div id="titleScreen">
  <h1>Domo Palubinsko Mi≈°kas</h1>
  <p style="color: white; margin-bottom: 20px;">Warning: This game contains loud sounds</p>
  <button id="startButton">START</button>
</div>
<div id="loadingScreen">LOADING...</div>
<div id="collectibles">Videos Found: 0/7</div>
<div id="flashlight"></div>
<div id="winScreen">
  <h1>You Won!</h1>
  <p>But at what cost...</p>
</div>

<script>
let scene, camera, renderer, player, enemy;
let collectibles = [];
let collectiblesFound = 0;
let enemySpeed = 0.05;
const WORLD_SIZE = 1000;
const TREE_COUNT = 200; // Increased from 100
const ROCK_COUNT = 100; // New constant for rocks
let trees = [];

// New variables for enemy mechanics
let isLookingAtEnemy = false;
let enemyLookTimer = 0;
let normalEnemySpeed = 0.05;
let lungeSpeed = 0.15;
let lastEnemyDistance = 0;

// Audio setup
const ambientSound = new Howl({
  src: ['/forest.mp3'],
  loop: true,
  volume: 0.3,
  autoplay: false
});

const footstepSound = new Howl({
  src: ['/foot.mp3'],
  volume: 0.4,
  rate: 1,
  loop: true
});

const jumpscareSound = new Howl({
  src: ['/baisu.mp3'],
  volume: 1.0
});

// Video sound setup
const videoSound = new Howl({
  src: ['dababygobbb.mp4'],
  spatial: true,
});

const pickupSound = new Howl({
  src: ['/ding.mp3'],
  volume: 0.5
});

let gameStarted = false;
let viewBobbing = 0;
let isEnemySpawned = false;
let isWalking = false;

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.015);
  
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.y = 2;
  
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  
  // Ground
  const groundTexture = new THREE.TextureLoader().load(createGroundTexture());
  groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
  groundTexture.repeat.set(20, 20);
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE),
    new THREE.MeshPhongMaterial({ map: groundTexture, side: THREE.DoubleSide })
  );
  ground.rotation.x = Math.PI/2;
  scene.add(ground);
  
  // Border walls
  const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
  const wallGeometry = new THREE.BoxGeometry(WORLD_SIZE, 20, 2);
  const walls = [
    { pos: [0, 10, WORLD_SIZE/2], rot: [0, 0, 0] },
    { pos: [0, 10, -WORLD_SIZE/2], rot: [0, 0, 0] },
    { pos: [WORLD_SIZE/2, 10, 0], rot: [0, Math.PI/2, 0] },
    { pos: [-WORLD_SIZE/2, 10, 0], rot: [0, Math.PI/2, 0] }
  ];
  
  walls.forEach(wall => {
    const mesh = new THREE.Mesh(wallGeometry, wallMaterial);
    mesh.position.set(...wall.pos);
    mesh.rotation.set(...wall.rot);
    scene.add(mesh);
  });
  
  // Trees with collision detection
  const treeTexture = new THREE.TextureLoader().load(createTreeTexture());
  const treeMaterial = new THREE.MeshPhongMaterial({ map: treeTexture });
  
  for(let i = 0; i < TREE_COUNT; i++) {
    const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, 15);
    const topGeometry = new THREE.ConeGeometry(4, 10, 8);
    const trunk = new THREE.Mesh(trunkGeometry, treeMaterial);
    const top = new THREE.Mesh(topGeometry, new THREE.MeshPhongMaterial({ color: 0x006400 }));
    
    const treeGroup = new THREE.Group();
    trunk.position.y = 7.5;
    top.position.y = 17;
    treeGroup.add(trunk);
    treeGroup.add(top);
    
    const x = Math.random() * WORLD_SIZE - WORLD_SIZE/2;
    const z = Math.random() * WORLD_SIZE - WORLD_SIZE/2;
    treeGroup.position.set(x, 0, z);
    
    trees.push({
      mesh: treeGroup,
      radius: 2,
      position: new THREE.Vector3(x, 0, z)
    });
    
    scene.add(treeGroup);
  }
  
  // Rocks creation
  createRocks();
  
  // Player
  player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 2, 1),
    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
  );
  scene.add(player);
  
  // Enemy (Edgar)
  const edgarTexture = new THREE.TextureLoader().load('/edgars.jpg');
  enemy = new THREE.Mesh(
    new THREE.PlaneGeometry(3, 3),
    new THREE.MeshBasicMaterial({ map: edgarTexture, transparent: true })
  );
  enemy.position.set(20, 2, 20);
  enemy.visible = false; // Hide enemy initially
  scene.add(enemy);
  
  createVideoCollectibles();
  
  const light = new THREE.AmbientLight(0x202020);
  scene.add(light);
  
  const flashlight = new THREE.SpotLight(0xffffff, 1);
  flashlight.angle = Math.PI/8;
  flashlight.penumbra = 0.2;
  flashlight.distance = 15;
  flashlight.castShadow = true;
  player.add(flashlight);
  flashlight.position.set(0, 0, 1);

  $("#startButton").click(startGame);
}

function startGame() {
  // Request fullscreen
  const element = document.documentElement;
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }

  $("#titleScreen").fadeOut(1000, () => {
    $("#loadingScreen").hide();
    gameStarted = true;
    ambientSound.play();
    animate();
  });
}

function createGroundTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = '#1a472a';
  ctx.fillRect(0, 0, 256, 256);
  
  // Add noise
  for(let i = 0; i < 5000; i++) {
    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
    ctx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
  }
  
  return canvas.toDataURL();
}

function createTreeTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = '#4a2810';
  ctx.fillRect(0, 0, 256, 256);
  
  // Add bark texture
  for(let i = 0; i < 1000; i++) {
    ctx.fillStyle = `rgba(30,15,0,${Math.random() * 0.3})`;
    ctx.fillRect(Math.random() * 256, Math.random() * 256, 4, 1);
  }
  
  return canvas.toDataURL();
}

function createVideoCollectibles() {
  const videoGeometry = new THREE.PlaneGeometry(2, 1.5);
  
  // Create video element and texture
  const video = document.createElement('video');
  video.src = 'dababygobbb.mp4';
  video.loop = true;
  video.muted = true;
  video.play();
  
  const videoTexture = new THREE.VideoTexture(video);
  
  // Create a glow effect by using multiple layers
  const videoMaterial = new THREE.MeshBasicMaterial({ 
    map: videoTexture,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide
  });

  // Add a glowing outline
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
  });
  
  for(let i = 0; i < 7; i++) {
    const videoGroup = new THREE.Group();
    
    // Create main video plane
    const videoMesh = new THREE.Mesh(videoGeometry, videoMaterial.clone());
    
    // Create glow plane (slightly larger)
    const glowGeometry = new THREE.PlaneGeometry(2.4, 1.9);
    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
    glowMesh.position.z = -0.01;  // Slightly behind main video
    
    videoGroup.add(glowMesh);
    videoGroup.add(videoMesh);
    
    videoGroup.position.x = Math.random() * (WORLD_SIZE-100) - (WORLD_SIZE-100)/2;
    videoGroup.position.z = Math.random() * (WORLD_SIZE-100) - (WORLD_SIZE-100)/2;
    videoGroup.position.y = 2;
    collectibles.push(videoGroup);
    scene.add(videoGroup);
  }
}

function createRocks() {
  const rockGeometry = new THREE.DodecahedronGeometry(0.5);
  const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
  
  for(let i = 0; i < ROCK_COUNT; i++) {
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    
    const scale = 0.5 + Math.random() * 1;
    rock.scale.set(scale, scale * 0.7, scale);
    
    const x = Math.random() * WORLD_SIZE - WORLD_SIZE/2;
    const z = Math.random() * WORLD_SIZE - WORLD_SIZE/2;
    rock.position.set(x, 0.2, z);
    rock.rotation.set(
      Math.random() * Math.PI,
      Math.random() * Math.PI,
      Math.random() * Math.PI
    );
    
    scene.add(rock);
  }
}

function isPlayerLookingAtEnemy() {
  const playerDirection = new THREE.Vector3();
  camera.getWorldDirection(playerDirection);
  
  const toEnemy = new THREE.Vector3();
  toEnemy.subVectors(enemy.position, player.position).normalize();
  
  // Calculate dot product to determine if player is looking at enemy
  const dotProduct = playerDirection.dot(toEnemy);
  
  // Return true if angle between vectors is less than 15 degrees
  return dotProduct < -0.96; // cos(15 degrees) ‚âà 0.96
}

// Function to handle enemy respawning
function respawnEnemy() {
  const angle = Math.random() * Math.PI * 2;
  const distance = 30; // Distance to respawn from player
  
  enemy.position.x = player.position.x + Math.cos(angle) * distance;
  enemy.position.z = player.position.z + Math.sin(angle) * distance;
}

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let rotation = 0;

document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case 'w': moveBackward = true; break; // Reversed
    case 's': moveForward = true; break;  // Reversed
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
  }
  
  // Only play footsteps if not already walking
  if((moveForward || moveBackward || moveLeft || moveRight) && !isWalking) {
    isWalking = true;
    footstepSound.play();
  }
});

document.addEventListener('keyup', (e) => {
  switch(e.key) {
    case 'w': moveBackward = false; break; // Reversed
    case 's': moveForward = false; break;  // Reversed
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
  }
  
  // Stop footsteps if no movement keys are pressed
  if(!moveForward && !moveBackward && !moveLeft && !moveRight) {
    isWalking = false;
    footstepSound.stop();
  }
});

document.addEventListener('mousemove', (e) => {
  rotation -= e.movementX * 0.002;
});

function checkCollision(pos1, pos2, threshold = 2) {
  return Math.abs(pos1.x - pos2.x) < threshold &&
         Math.abs(pos1.z - pos2.z) < threshold;
}

function checkTreeCollision(playerPos) {
  for(let tree of trees) {
    const dx = playerPos.x - tree.position.x;
    const dz = playerPos.z - tree.position.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    if(distance < tree.radius) return true;
  }
  return false;
}

function jumpscare() {
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('/edgars.jpg') center center no-repeat;
    background-size: cover;
    z-index: 1000;
  `;
  document.body.appendChild(overlay);
  jumpscareSound.play();
  setTimeout(() => {
    location.reload();
  }, 1000);
}

function checkAmbientSound() {
  if(gameStarted && !ambientSound.playing()) {
    ambientSound.play();
  }
}

function animate() {
  requestAnimationFrame(animate);
  
  if(!gameStarted) return;
  
  const speed = 0.15; // Reduced speed
  const newPosition = player.position.clone();
  
  if(moveForward) {
    newPosition.x += Math.sin(rotation) * speed;
    newPosition.z += Math.cos(rotation) * speed;
  }
  if(moveBackward) {
    newPosition.x -= Math.sin(rotation) * speed;
    newPosition.z -= Math.cos(rotation) * speed;
  }
  if(moveLeft) {
    newPosition.x -= Math.cos(rotation) * speed;
    newPosition.z += Math.sin(rotation) * speed;
  }
  if(moveRight) {
    newPosition.x += Math.cos(rotation) * speed;
    newPosition.z -= Math.sin(rotation) * speed;
  }
  
  // Check if new position is valid (within bounds and not colliding with trees)
  if(!checkTreeCollision(newPosition) &&
     Math.abs(newPosition.x) < WORLD_SIZE/2 - 2 &&
     Math.abs(newPosition.z) < WORLD_SIZE/2 - 2) {
    player.position.copy(newPosition);
  }
  
  // View bobbing effect
  if(moveForward || moveBackward || moveLeft || moveRight) {
    viewBobbing += 0.1;
    camera.position.y = 2 + Math.sin(viewBobbing) * 0.1;
  } else {
    camera.position.y = 2;
  }

  camera.position.x = player.position.x;
  camera.position.z = player.position.z;
  camera.rotation.y = rotation;
  
  // Update collectibles rotation and glow
  collectibles.forEach(videoGroup => {
    if(videoGroup.visible) {
      videoGroup.rotation.y += 0.02;
      videoGroup.position.y = 2 + Math.sin(Date.now() * 0.002) * 0.2;
      
      // Pulse the glow
      const glowMesh = videoGroup.children[0];
      glowMesh.material.opacity = 0.4 + Math.sin(Date.now() * 0.003) * 0.2;
    }
  });
  
  // Enemy behavior
  if(isEnemySpawned) {
    // Calculate distance to player
    const distanceToPlayer = player.position.distanceTo(enemy.position);
    
    // Check if player is looking at enemy
    if(isPlayerLookingAtEnemy()) {
      if(!isLookingAtEnemy) {
        isLookingAtEnemy = true;
        enemyLookTimer = Date.now();
      }
      
      // If looked at for more than 3 seconds, trigger lunge
      if(Date.now() - enemyLookTimer > 3000) {
        enemySpeed = lungeSpeed;
      }
    } else {
      isLookingAtEnemy = false;
      enemySpeed = normalEnemySpeed * (1 + (collectiblesFound * 0.2)); // Return to normal speed with collection multiplier
    }
    
    // Check if enemy is too far and should respawn
    if(distanceToPlayer > 50) {
      respawnEnemy();
    }
    
    // Update enemy movement
    const directionX = player.position.x - enemy.position.x;
    const directionZ = player.position.z - enemy.position.z;
    const length = Math.sqrt(directionX * directionX + directionZ * directionZ);
    
    enemy.position.x += (directionX/length) * enemySpeed;
    enemy.position.z += (directionZ/length) * enemySpeed;
    enemy.lookAt(player.position);
    
    lastEnemyDistance = distanceToPlayer;
  }
  
  // Check collectibles
  collectibles.forEach((videoGroup, index) => {
    if(videoGroup.visible && checkCollision(player.position, videoGroup.position)) {
      videoGroup.visible = false;
      collectiblesFound++;
      pickupSound.play();  // Play pickup sound
      
      // Spawn enemy after first collectible
      if(collectiblesFound === 1) {
        enemy.visible = true;
        isEnemySpawned = true;
      }
      
      enemySpeed *= 1.2;
      $("#collectibles").text(`Videos Found: ${collectiblesFound}/7`);
      
      if(collectiblesFound >= 7) {
        $("#winScreen").css('display', 'flex').hide().fadeIn(1000);
        setTimeout(() => {
          location.reload();
        }, 5000);
      }
    }
    
    if(videoGroup.visible) {
      const distance = player.position.distanceTo(videoGroup.position);
      videoSound.pos(videoGroup.position.x, videoGroup.position.y, videoGroup.position.z, videoSound.id);
      videoSound.volume(Math.max(0, 1 - distance/20));
    }
  });
  
  if(checkCollision(player.position, enemy.position)) {
    jumpscare();
  }
  
  checkAmbientSound(); // Ensure ambient sound plays continuously
  renderer.render(scene, camera);
}

init();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

renderer.domElement.addEventListener('click', () => {
  renderer.domElement.requestPointerLock();
});
</script>

</body></html>